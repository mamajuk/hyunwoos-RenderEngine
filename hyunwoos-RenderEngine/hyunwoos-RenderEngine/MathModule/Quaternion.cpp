#include "Quaternion.h"

	/**************************************************************************************
	 *   1: 복소수란?
	 ************
	 (0): 사원수는 복소수의 확장이니, 사원수부터 알고 가보도록 하자.

	 (1): 고대 수학자들은 이차방정식을 풀다가 x² + 1 = 0 와 같이, 어떤 수를 제곱해도 적절한 결과를 낼 수 없는
		  상황에 직면했다. 이를 해결하기 위해 제곱했을 때 -1이 되는 허수체계 i를 만들었다.

	 (2): 허수를 단독으로 사용했을 때, 허수간의 곱셈에서 결과가 허수의 범위에서 나가게 되서( i² = -1 )
		  체(Field)를 만족하지 않는다. 기존 실수 체계에서 허수를 함께 다루기 위해서는 허수도 체(Field)를
		  만족해야한다.

	 (3): 기존 실수항 a에 새로운 허수항 bi를 붙여 2차원으로 확장한 것이 복소수 ( a+bi ) 다. 복소수 체계에서는 연산
		  결과가 항상 복소수 안에서 닫혀있기에 체(Field)를 만족하며, 기존 실수 체계를 확장한 것이다보니 기존 실수
		  체계에서도 완벽히 호환된다. 동시에 허수를 사용해서 기존 실수 문제도 해결할 수 있게 된 것이다.

	 (4): 복소수는 간단하게 실수부, 허수부 차원으로 구성된 2차원 벡터 ( a+bi ) = ( a, b )의 형태로도 나타낼 수 있다.
	 */





	 /****************************************************************************************************
	  *   2: 복소수의 곱셈
	  ************
	  (1): 복소수는 ( a+bi ) 두 항의 덧셈이다. 복소수는 체(Field)의 구조를 만족하기 때문에,
		   복소수간의 곱셈은 두개의 2항식의 곱셈이다. 즉 분배해서 곱해줘야 한다는 것이다.

	  (2): 예를 들어서, ( a+bi )( a`+b`i ) = ( aa` + ab`i + a`bi -bb` ) = ( aa`-bb`, ab`i + a`bi )가 되겠다.
	  */





	 /********************************************************************************************************
	  *   3: 복소수의 켤레와 복소수의 크기
	  ***************
	  (1): 켤레( Conjugate )는 허수부에 음수를 붙여준 것을 의미한다. 예를 들어서 복소수 ( 0, i )의 켤레는
		   ( 0, -i )가 된다. 

	  (2): 복소수의 크기는 자기자신의 켤레를 곱해주면 된다. 예를 들어서 ( 0, i )( 0, -i ) = ( 0+0+0+-(-1) ) = ( 1 ) = ( 1, 0 )
		   즉 실수부만 남게되는데, 이 실수부가 복소수의 크기값이다. 따라서 편하게 복소수의 크기는 sqrt(실수부² + 허수부²)
		   라고 볼 수 있겠다. 
	   */



	   /********************************************************************************************************
		*    4: 회전 복소수의 정리
		**********
		(1): 단위 복소수는 크기가 1인 복소수를 의미한다. 어떤 단위 복소수 ( 1 + 0i )가 있다고 해보자.
			 그리고 또 다른 단위 복소수 ( 0 + i )를 곱해보자. ( 1 + 0i )( 0 + i ) = ( 0+i+0+0 ) = ( 0, 1 )
			 이 결과를 복소평면( 카타시안 좌표계에서의 +x축을 실수부, +y축을 허수부로 나타낸 좌표계 )
			 에 나타내보자. 처음값이였던 ( 1 + 0i ) 에서 ( 0 + i )로 반시계방향으로 90º 회전이라고 볼 수 있다.

		(2): 복소수 ( 0 + i )의 켤레 ( 0 + -i )를 ( 0 + i )에 곱해보자. ( 0 + i )( 0 + -i ) = ( 0+0+0+1 ) = ( 1, 0 )
			  처음값이였던 ( 0, 1 )에서 ( 1, 0 )로 시계방향으로 90º 회전했다. 즉 역회전했다고 볼 수 있다.
			  만약 어떤 단위 사원수에 그 단위 사원수의 켤레를 곱하면 복소수의 항등원인 ( 1, 0 )이 나온다.
			  이의 경우 지금까지의 회전에서 다시 원래대로 되돌아갔다고 볼 수 있겠다.

		(3): ( 0 + i )는 어떻게보면 ( cos90º + sin90ºi )라고 볼 수 있겠다. 여기서 ( cosθ + sinθi )의 형태를 '회전 복소수'
			 라고 한다. 회전 복소수간의 곱셈은 아무리 반복되어도 크기는 1이 되는데, 두 회전 복소수의 곱을 통해 알 수 있다:
			 ( cos20º + sin20ºi )( cos30º+sin30ºi ) = ( cos20ºcos30º + cos20ºsin30ºi + cos30ºsin20ºi - sin20ºcos30º ) 
			 = ( cos20ºcos30º - sin20ºcos30º,  cos20ºsin30º + cos30ºsin20º ) 이는 각각 
			코사인 덧셈정리( cos(α+β) = cosαcosβ - sinαsinβ )와 사인 덧셈정리( sin(α+β) = sinαcosβ + cosαsinβ )와 동일하다.
			따라서 회전 복소수를 곱하는 것은 그저 회전이 가중될 뿐이다. 이는 기하학적으로 봤을 때, 회전되어있는 점을 나타내는 1x2 열행렬 [ cosα, sinα ]에
			2x2 열기준 행렬 [cosβ+sinβ][-sinβ, cosβ ]를 곱해준 것과 같다. 

		(4): 특정 위치의 점을 나타내는 복소수에 회전 복소수를 곱하면, 그 점은 회전 복소수에 설정된대로 회전된다:
			 (x + yi)( cosθ + sinθi ) = ( xcosθ + xsinθi + ycosθi - ysinθ ) = ( xcosθ - ysinθ, xsinθi + ycosθi ) 즉 회전 복소수는
			 회전행렬과 같이 회전량을 보관하는 도구이며, 같은 회전 복소수를 곱할 때마다 회전량이 가중되서 저장된다고 볼 수 있다.
		*/




		/************************************************************************************************************
		 *   5: 사원수란?
		 *********
		 (1): 3차원에서 특정 회전축에 직교하는 구형 평면의 회전 정보를 저장하기위한 도구로, 기존 복소수에서 허수 j, k를 붙여 4차원으로 
			 확장한 것이 사원수( a + bi + cj + dk )다. 기본적인 덧셈과 곱셈 연산 방식은 복소수와 동일하며, ( a, b, c, d )처럼
			 실수, 허수i, 허수j, 허수k 차원의 4차원 벡터로 표현할 수 있으며, 회전축으로 사용되는 3개의 허수 i,j,k를 3차원 벡터로
			 묶어서 ( a, n )과 같이 표현할 수 있다.

		(2): 복소수가 2차원 회전이라면, 3차원 회전에서는 삼원수를 쓰는게 맞지 않나 생각할 수 있다. 하지만 하나의 허수는
			 하나의 구형평면을 얼마나 회전시킬지에 대한 정보를 만들어내는데 사용된다. 그렇기에 구형평면이 하나만 있는 2차원에서의
			 회전은 복소수로도 충분하다. 하지만 삼원수는 허수가 2개밖에 없기에 세개의 구형평면을 얼마나 회전시킬지에 대한 정보를
			 만들어낼 수 없다. 따라서 사원수로 확장해 3개의 허수를 확보할 필요가 있던 것이다.

		(3): 복소수의 곱셈처럼 사원수도 동일한 곱셈 방식을 사용한다. 하지만 추가적인 규칙을 세우지 않으면 문제가 발생하는데,
			  ( a+bi+cj+dk )( a`+b`i+c`j+d`k )에서 좌변의 bi를 우변의 각 항에게 분배를 해보자: ( a`bi -bb` + bcij + bd`ik )
			 실수만 남은 것은 상관없지만, 문제는 다른 허수 i, j나 i,k간의 곱이 사원수 내의 어떤 성분으로 나와야하는지를 모른다.
			 복소수의 곱은 그 결과가 항상 복소수라는 결과로 닫히기에 괜찮지만, 사원수에서는 허수 i² = j² = k² = -1 이라는 규칙
			 만으로는 사원수의 곱이 항상 사원수의 결과로 닫히지 않으며, 곱셈을 정의할 수 없다. 따라서 ijk = -1이라는 규칙을 새롭게 추가한다.
			 덕분에 ∴ i(jk) = -1,  ∴ jk = i,  ∴ (ij)k = -1, ∴ ij = k 와 같이 각 허수들을 치환해 나가면서 다른 각 허수들의 곱이 사원수 내의
			 성분으로 나타나 사원수의 곱셈이 성립된다. 다만 허수들이 곱하는 순서에 따라서 결과가 달라지기 때문에, 사원수의 곱은
			 교환법칙이 성립되지 못한다. 따라서 체는 아니지만, 복소수처럼 결합법칙과 분배법칙, 0이 아닌 역원이 존재하기에 회전을 표현하기에는
			 충분하다. 특히 2차원에서의 회전은 회전 순서가 상관이 없기에, 교환법칙이 성립되는 회전 복소수는 '체(Field)'의 성질을 가진다. 
			 하지만 3차원에서는 X축 30º->Y축 30º 순으로 회전을 했을 때와, Y축 30º->X축 30º순으로 회전했을 때와 결과가
			 다르다. 때문에 오히려 교환법칙이 성립하지 않는 것은 3차원 회전을 나타내기에 가장 자연스러운 형태라고 볼 수 있겠다.

		(4): 회전 사원수는 오일러 공식( e^nθ = cosθ + sinθi )을 사용해서 간단하게 나타낼 수 있다. 회전축 n에서 45º 회전시키는
			 회전 사원수라면 e^n45θ 와 같이 나타내는게 가능하다. 
		 */





		 /********************************************************************************************************************
		  *    6: 사원수의 곱셈의 정리
		  **********
		  (1):	사원수는 4항식이기 때문에, 사원수의 곱은 굉장히 길고 난잡하다. 앞서 알아봤듯이, ijk = -1이라는 규칙 때문에, 
				 교환법칙은 성립하지 않는다. 허수부의 곱은 순서를 바꾸면 안되며, 스칼라만이 앞으로 빠져나올 수 있음을
				 주의하면서 ( a+bi+cj+dk )( a`+b`i+c`j+d`k )를 전개해보자:
				 ∴ ( aa` + ab`i + ac`j + ad`k ) + ( a`bi - bb` + bc`ij + bd`ik ) + ( a`cj + cb`ji - cc` + cd`jk ) + ( a`dk + b`dki + dc`kj - dd` )
				 위 식에서 ijk = -1 규칙에 의해 각 다른 허수간의 곱셈을 다른 허수로 치환할 수 있을 것이다:
				[∴ ijk = -1], [∴ i(jk) = -1], [∴ jk = i], [∴(ij)k = -1], [∴ij = k], [∴ik = -j], [∴kj = -i], [∴ki = j],  [∴ji = -k]
				 ∴ ( aa` + ab`i + ac`j + ad`k ) + ( a`bi - bb` + bc`k - bd`j ) + ( a`cj - cb`k - cc` + cd`i ) + ( a`dk + b`dj - dc`i - dd` )
     
		  (2): (1)에서 정리한 식은 너무 복잡하다. 실수는 맨좌측으로 모으고, 같은 허수를 사용하는 스칼라들을 묶어보자:
			   ∴ (   aa`-bb`-cc`-dd`   +   (ab` + a`b + cd` - dc`)i    +   (ac` -bd` + a`c + b`d)j   +   (ad` + bc` - cb` + a`d)k   )  
			   정리된 위 식을 보다보면, 내적과 외적 형태가 보인다. 앞서 사원수는 3개의 허수 i,j,k를 회전축을 나타내는 3차원 벡터로 묶어서 ( a, n )과 같이
			   표현할 수 있다고 했다. 따라서 ijk 차원에 있는 스칼라들을 사용하는 내적과 외적으로 정리해보자. 먼저 실수부를 보면,
			   3차원 벡터 n의 내적 (x²+y²+z²)이 보인다. 내적의 결과는 스칼라이기 때문에, 음수곱을 묶어낼 수 있다:
			   ∴(  aa` - (n·n`),    (ab` + a`b + cd` - dc`),    (ac` -bd` + a`c + b`d),   (ad` + bc` - cb` + a`d)  )
			   이번엔 회전축 벡터의 각 차원을 봐보자. 외적( yz`-zy` , zx`-xz`, xy`-yx` )가 보인다. 외적의 결과는 벡터지만, 외적이랑 비슷하니 외적으로 표현할
			   뿐이라는 것을 명심하자. 외적의 연산을 보기 쉽게 보면 다음과 같다: ( nxn ) = ( cd`-dc`, db`-bd`, bc`-cb` ) 그리고 위 식에서 외적성분을 묶어내면
			   다음과 같이 전개된다:
			   ∴(  aa` - (n·n`),    (ab` + a`b + [cd` - dc`] ),    (ac` [-bd`] + a`c + [b`d]),   (ad` + [bc` - cb`] + a`d)  )
			   = ∴(  aa` - (n·n`),    (ab` + a`b),    (ac` + a`c),   (ad` + a`d)  ) + ( 0,  [cd` - dc`], [db`-bd`], [bc` - cb`])
			   = ∴(  aa` - (n·n`),    (ab` + a`b),    (ac` + a`c),   (ad` + a`d)  ) + ( nxn` ) 
			   외적을 정리하고 나니, 두 사원수의 실수부와 허수부를 교차해서 곱한값만 남았다. 이를 정리하면 다음과 같이 최종 정리된다:
			   = ∴(  aa` - (n·n`),    (ab` + a`b),    (ac` + a`c),   (ad` + a`d)  ) + ( nxn` ) + ( 0, a`b, a`c, a`d ) + ( 0, ab`, ac`, ad` )
			   = ∴(  aa` - (n·n`),    0, 0, 0 ) + ( nxn` ) + a`n + an`
			   = ∴aa` - (n·n`) + ( nxn` ) + a`n + an`

		  (3): 사원수도 복소수처럼 자기자신의 켤레( a - bi - cj -dk )를 곱하면 크기의 제곱이 나온다. 직접 한 번 전개해서 이를 알아보자. 
				 다음은 사원수의 곱의 결과를 ( a, n )이 아닌, ( a+bi+cj+dk )의 형태로 표현했다( []안에 있는게 외적 성분. ):
			   ∴ (   aa-bb-cc-dd  -  (ab + ab + [cd - dc] )i -  (ac [-bd] + ac + [bd])j  -  (ad + [bc - cb] + ad)k  )
				하지만 평행한 벡터끼리의 외적은 0벡터( sin은 θ가 0이면 0이기 때문에, 외적의 크기가 0이다. )가 된다:
			   ∴ (   aa-bb-cc-dd  -  (ab + ab )i -  (ac + ac )j  -  (ad + ad)k  )
			   그리고 켤레이기 때문에, 세 허수의 스칼라는 완전히 소거되어 0이 된다:
				∴ (   aa-bb-cc-dd  + (ab - ab )i  + (ac - ac )j  +  (ad - ad)k  )
			   ∴ (   aa-bb-cc-dd  )
			   ∴ (  a² + b² + c² + d² ) 
			   이렇게 보면 결과는 자기 자신의 각 스칼라부의 제곱만 남게 되며, 여기에 루트를 씌우면 크기를 구할 수 있을 것이다.

		  */






		  /**************************************************************************************************************************
		   *   7: 회전 사원수의 정리
		   *********
		   (1): 회전 복소수처럼, 회전 사원수는 ( cosθ+sinθn )으로 정의된다. 


		   (2):  회전 복소수처럼, 회전 사원수 간의 곱셈의 결과는 항상 회전 사원수이며, 그 결과의 크기는 항상 1로 보존된다. 
				 회전축이 다른 두 회전 사원수가 연속적으로 곱해진 결과의 크기를 구했을 때, 크기가 1이라면 회전 사원수 간의 
				 곱셈은 노름 보존이 된다는 성질을 증명해낼 수 있을 것이다. 회전할 두 회전 사원수가 있다고 해보자:   
				 ∴q = ( cos1 + sin1n ),  ∴q` = ( cos2 + sin2n` )
				 q` 회전을 적용하고나서 q 회전을 적용한다면, 사원수의 곱은 함수합성처럼 오른쪽에서 왼쪽으로 진행이 되기 
				 때문에 회전 결과는 다음과 같이 전개된다:   
				 ∴qq` = ( cos1 + sin1n )( cos2 + sin2n` ) = ( cos1cos2 - sin1sin2(n·n`) + sin1sin2(nxn`) + cos1sin2n` + cos2sin1n )
				 그렇다면 이 연속 회전한 사원수의 켤레는 다음과 같을 것이다:
				∴(qq`)* = (( cos1 + sin1n )( cos2 + sin2n` ))* = ( cos1cos2 - sin1sin2(n·n`) - sin1sin2(nxn`) - cos1sin2n` - cos2sin1n )
				그렇다면 직접 각 켤레들의 곱을 한 결과는 어떨까?
				∴q*q`*  = ( cos1 - sin1n )( cos2 - sin2n` ) = ( cos1cos2 -sin1sin2(n·n`) + sin1sin2( nxn`) -cos1sin2n` - cos2sin1n )
				잘 보면 외적성분의 기호만 다르다. 외적의 결과에만 -1을 곱해주는 것은 불가능하기에, 한 번 각 켤레들의 곱의 순서를 바꿔서 해보자.
				∴q`*q*  = ( cos1 - sin1n )( cos2 - sin2n` ) = ( cos1cos2 -sin1sin2(n·n`) + sin1sin2( n`xn ) -cos1sin2n` - cos2sin1n )
				다 똑같은데 외적의 순서가 달라졌다. 예를 들어 왼손 좌표계에서 X x Y = Z다. 여기서 순서를 바꿔서 Y x X = -Z가 나오지만,
				모든 항의 부호를 뒤집는다면 결과는 -Y x -X = Z 즉 X x Y 의 결과와 똑같기에 치환이 가능하다는 말이다. 이 예시처럼 q`*q*의 외적성분
				sin1sin2( n`xn )에서 외적의 순서를 바꾸고 외적항의 부호를 뒤집으면 (qq`)*의 외적성분과 동일하다:
				∴q`*q*  = ( cos1 - sin1n )( cos2 - sin2n` )     = ( cos1cos2 -sin1sin2(n·n`) - sin1sin2( nxn` ) -cos1sin2n` - cos2sin1n )
				∴(qq`)* = (( cos1 + sin1n )( cos2 + sin2n` ))* = ( cos1cos2 - sin1sin2(n·n`) - sin1sin2(nxn`) - cos1sin2n` - cos2sin1n )
				오른쪽에서 왼쪽으로 곱이 진행되는 사원수 곱의 특성상, (q`*q*)(qq`) 와 같이 계산이 진행될 것이다.
				교환법칙이 성립되지 않는 3차원의 연속 회전의 결과를 무효화하려면, 기존 회전 순서에서 역순으로 풀어나가야 한다.
				따라서 기존 회전 순서의 반대 방향으로 역회전들의 연속회전을 만드는 것은 당연한 것이라고 볼 수 있겠다.
				회전 사원수에 같은 회전 사원수의 켤레를 곱해나가면 결국 모든 회전이 무효가되어 사원수의 항등원( 1 + 0n )이 나온다.
				회전 사원수는 단위 사원수이기에 결국 크기는 1이며, 회전 사원수간의 곱셈은 연속 회전된 회전 사원수를 만들어낼 뿐이다.


		   (3):  회전축이 다른 회전 사원수 간의 곱의 결과는, 각 회전이 합성되어 새로운 회전에 대한 회전축과 회전량을 가진 회전 사원수
				 가 된다. 이를 회전 사원수간의 곱셈을 직접해서 확인해보자:
				 ∴q = ( cos1 + sin1n ),  ∴q` = ( cos2 + sin2n` )
				 ∴qq` = ( cos1 + sin1n )( cos2 + sin2n` ) = ( cos1cos2 - sin1sin2(n·n`) + sin1sin2(nxn`) + cos1sin2n` + cos2sin1n )
				 잘 보면 내적성분과 외적성분, 그리고 삼각함수의 덧셈정리가 보인다. 같은 회전축을 사용하는 회전 사원수 간의 곱이라면 
				 회전축 n이 서로 평행해서 외적 성분이 0이되며, 내적 성분은 1이 된다. 원래 회전 사원수를 곱하는 순서에 따라 외적 결과의 
				 방향이 달라져 교환법칙이 성립하지 않았지만, 외적 성분이 사라짐으로서 교환 법칙이 성립하게 된다. 또 이 경우에만 
				 삼각함수의 덧셈 법칙으로 회전 사원수 간의 곱의 크기가 왜 항상 1로 유지되는지, 왜 회전이 가중됨을 손쉽게 증명할 수 있다:
				∴ 코사인 덧셈정리( cos(α+β) = cosαcosβ - sinαsinβ )와 사인 덧셈정리( sin(α+β) = sinαcosβ + cosαsinβ )
				 ∴ qq` = ( cos1 + sin1n )( cos2 + sin2n ) = ( cos1cos2 - sin1sin2(n·n) + sin1sin2(nxn) + cos1sin2n + cos2sin1n ) 
						 = ( cos1cos2 - sin1sin2 + (cos1sin2 + cos2sin1)n  )
						 = ( cos(1+2) + sin(1+2)n )
				 만약 다른 회전축을 사용하는 회전 사원수 간의 곱이라면, 삼각함수의 덧셈정리 항들이 내적/외적/교차항 성분으로 분해되어
				 삼각함수 덧셈 정리로 증명할 수가 없다. 따라서 새로운 회전축과 회전량을 만들어내기에 회전이 합성된다는 느낌으로 이해해도 
				 충분할 것이다.
    

		   (4):  회전 행렬은 벡터에 곱했을 때 회전된 벡터가 나올 수 있도록 하는 도구다. 이는 회전 사원수도 마찬가지이다. 하지만
				 회전 사원수의 곱은 회전 사원수로 닫혀야 한다. 따라서 실수부가 0이고, 회전시킬 벡터가 허수부인 순허수 사원수 
				 v = (0, v)를 회전시킬 벡터로서 사용한다. 그리고 임의의 회전 사원수를 임의의 순허수 사원수에 곱해서 벡터를 회전 시켜보자:
				∴ q = ( cosθ + sinθn ),  ∴v = ( 0 + v )
				∴qv = ( cosθ + sinθn )( 0 + v ) = ( 0 -sinθ(n·v) + sinθ(nxv) + cosθv ) = ( -sinθ(n·v) + sinθ(nxv) + cosθv )
				하지만 문제가 있다. 회전 행렬과 벡터를 곱하면 결과는 벡터이지만, 회전 사원수와 순허수 사원수의 곱은 순허수 사원수가 아니기에
				불편하다. 또 벡터부를 보면 sinθ(nxv) + cosθv만 있는데, 이는 로드리게스 회전에서 회전축과 직교하는 평면의 회전은 끝냈지만, 회전축과
				평행하는 벡터 성분을 더하지 않아 제대로 벡터가 회전되지 못했음을 의미한다. 기존 회전 사원수는 회전 정보를 다루기에는 정말 좋은 형태이기에,
				회전 사원수는 회전 정보를 저장하는데에만 사용하고, 벡터를 회전시킬 때에는 별도의 로드기네스 회전식을 만들어서 사용하면 될 것이다.
				지금부터 이 식을 유도해보자. 기존 qv 대신 회전축과 직교하는 v의 성분과의 곱셈 qvㅗ로 곱셈을 진행해보자. 직교하면 0이 되는 내적의 성질로
				인해서 실수부가 제거되어 순허수 사원수가 된다. 그 결과에 회전축과 평행하는 v의 성분을 더하면 로드리게스 회전을 끝낼 수 있다:
				∴qvㅗ = ( cosθ + sinθn )( 0 + vㅗ ) = ( 0 -sinθ(n·vㅗ) + sinθ(nxvㅗ) + cosθvㅗ ) = ( sinθ(nxv) + cosθv )
				∴R(v) = v|| + qvㅗ

		   (5): 하지만 매번 회전축과 평행/직교하는 성분을 구하기에는 너무 번거롭다. 근데 R(v) = v|| + qvㅗ에서 어떻게든 qvㅗ의 곱셈 순서를 바꿔서
				 v|| + vㅗ의 형태로 만든다면 이를 v 하나로 치환시켜 식이 단순해진다. 지금부터 이 단순화 과정을 할건데, 식을 직관적으로 표현하기 위해서
				회전 사원수를 오일러 공식 e^iθ = cosθ + sinθi을 사용하겠다. 회전 사원수의 회전축은 항상 크기가 1이다. 따라서 순허수 회전 사원수의 제곱은 -1이기에:
				∴( 0 + n )² = ( 0+n )( 0+n ) = ( 0-(n·n)+(nxn)+0+0 ) = -1 
				오일러 공식의 허수 i를 회전축 n으로 치환시켜서 표현할 뿐이라면 ∴q = e^nθ = cosθ + sinθn과 같이 표현하는게 가능하다. 회전 사원수 e^nθ는
				절반 각도의 회전 사원수 간의 곱셈으로 표현이 가능하다: ∴ e^nθ = e^nθ/2 · e^nθ
				따라서 기존 로드리게스 회전식 R(v) = v|| + qvㅗ는 R(v) = v|| + e^nθ/2 ·e^nθ/2 ·vㅗ와 같이 표현이 가능할 것이다.
				그런데 잘 생각해보면 v||는 1 · v||와 같이 스칼라 1이 앞에 곱해져있다고 볼 수 있다. 결과만 같으면 치환도 가능하다. 따라서 v|| 앞에 곱해진 스칼라는
				회전의 역회전, 즉 회전 사원수에 켤레를 곱했다고 볼 수 있다. 따라서 다음과 같이 전개된다:
				∴ R(v) = v|| + e^nθ/2 · e^nθ/2 · vㅗ
			   ∴  R(v) = e^nθ/2 · e^n-θ/2 · v|| + e^nθ/2 · e^n-θ/2 · vㅗ
			   이제 두 항에는 공통적인 요소인 e^nθ/2를 하나씩 묶을 수 있다. 회전 사원수의 곱은 교환법칙이 성립되지 않기에, 각 항의 우측에 있는 e^nθ/2만을 묶어낼 수 있다:
			   ∴ R(v) = e^nθ/2( e^n-θ/2 · v|| + e^nθ/2 · vㅗ )
			   이제 e^n-θ/2을 묶어내면 ( v|| + vㅗ )의 형태가 나온다. 하지만 e^n-θ/2가 하나만 존재한다. e^nθ/2 · vㅗ의 곱셈 순서가 뒤집히고 e^nθ/2의 역회전이면 좋을 것 같다.
			   두 식을 비교 해보자:
			   ∴ e^nθ/2 · vㅗ    = q`vㅗ    = ( w + n )( 0 + vㅗ )    = ( -(n·vㅗ) + (nxvㅗ) + wvㅗ ) = ( (nxvㅗ) + wvㅗ )
			   ∴ vㅗ · e^n-θ/2   = vㅗq`*   = ( 0 + vㅗ)( w - n )      = (  (vㅗ·n) - (vㅗxn) + wvㅗ ) = ( -(vㅗxn) + wvㅗ )
			   위 두 식을 비교해보면 회전축과 vㅗ는 직교해서 내적성분이 제거되서, 외적성분의 순서와 부호만 다름을 알 수가 있다. 근데 vㅗ · e^n-θ/2의 외적 성분(vㅗxn)의 부호가
			   -1이라면 결국 ∴ q`vㅗ = vㅗq`*가 되어 치환할 수 있게 된다:
			   ∴ R(v) = e^nθ/2( e^n-θ/2 · v|| + vㅗ · e^n-θ/2 )
			   이제 좌항의 순서만 바꾸면 끝이다. 그렇다면 좌항의 곱을 순서를 바꿨을 때, 치환이 가능한지 비교해보자. 참고로 서로 평행한 벡터와의 외적의 결과는 0벡터다. 하지만
			   여기서는 진짜 외적이 아닌 외적 성분과 비슷해서 외적으로 표현하던 것 뿐이기 때문에 결과는 0이라고 보면 된다:
			   ∴ e^n-θ/2 · v|| = q`v|| = ( w-n )( 0 + v|| ) = ( 0 + ( n·v|| ) - (nxv||) + wv|| + 0 ) = ( (n·v||) + wv||  )
			   ∴ v|| · e^n-θ/2 = v||q` = ( 0 + v|| )( w-n ) = ( 0 + (v||n) - (v||xn) + 0 + wv|| )   = ( (v||n) - wv||    )
			   위 두 식을 비교해보면 그냥 같은 값이다. 따라서 q`v|| = v||q`가 되어 치환할 수 있게 된다:
			   ∴ R(v) = e^nθ/2(  v|| · e^n-θ/2 + vㅗ · e^n-θ/2 )
			   각 항의 우측에는 공통적인 요소인 e^n-θ/2를 하나씩 우측으로 묶을 수 있다:
			   ∴R(v) = e^nθ/2( v|| · vㅗ )e^n-θ/2
			   v|| · vㅗ = v다. 즉 최종 정리된 결과는 다음과 같다:
			   ∴R(v) = e^nθ/2 · v · e^n-θ/2 = q`vq`*
			   때문에 회전 사원수에 회전량을 설정할 때, 절반으로 만들어서 줘야 이후 최종 회전 사원수 q를 통해 특정 벡터 v에 로드리게스 회전을 적용할 때 각도를 절반으로 할
			  필요가 없어지게 된다.

		    (6): 특정 벡터를 로드리게스 회전시키는 R(v) = qvq*의 회전 결과는 오른손 좌표계를 따른다. X축을 나타내는 벡터 v와 Y축으로 90º회전시키는 회전사원수 q가 있다고
				 해보자. 그렇다면 정리하지 않은 로드기네스 회전식에서는 R(v) = ( 0, v|| ) + ( 0, s(nxv) + cv )와 같이 된다. 잘보면 회전축 n과 직교하는 회전평면의 Y축을 구하기
				 위해서 회전축과 벡터 v간의 외적(nxv)이 진행되는데, 이는 YxX = -Z라고 볼 수 있다. 이를 카타시안 좌표계에서의 2차원 평면으로 본다면 Z가 y축이고 X축은 그대로
				 X축으로 볼 수 있다. 따라서 두 기저에 c과 s을 곱하고 선형결합하면 결과 벡터는 반시계로 회전하게 된다. 이를 Z축의 +방향이 앞쪽인 왼손좌표계의 관점에서 해석하면
				 회전축과 직교하는 회전평면의 Y축이 뒤쪽으로 보이며, 회전평면의 두 기저에 각각 c과 s을 곱하고 선형결합을 했을 때의 결과 벡터는 시계방향 회전을 하는 것처럼 보이게
				 된다. 반면 Z축의 +방향이 뒤쪽인 오른손좌표계의 관점에서 해석하면 회전축과 직교하는 회전평면의 Y축이 앞쪽으로 보이며, 회전평면의 두 기저에 각각 c과 s를 곱해주고
			     선형결합을 했을 때의 결과벡터는 반시계 방향 회전을 하는 것처럼 보일 뿐이다.

			(7): 근데 생각해보면 어차피 실수부는 0이 나오기 때문에 결과가 순허수 사원수인 것이다. 따라서 실수부까지 굳이 계산하는 것은 낭비다. 계산량을 줄이기 위해서
				 기존 최종 계산식에서 실수부를 제거해보자. 최종 로드기네스 회전 수식을 실수부를 w로, 허수부를 r로 봤을 때 곱셈을 전개해보자.
				 ∴q    = ( cosθ/2, sinθ/2n ) = ( w, r )
				 ∴R(v) = qvq*
						 = ( w, r )( 0,v )( w, -r )
					 = ( w, r )( (v·r), -(v x r) + wv )
						 = ( w(v·r) - (r·(-(v x r) + wv)), (rx(-(v x r) + wv)) + w(-(v x r) + wv ) + (v·r)r )
				전개된 위 식에서 실수부만 전개시켜보자. 일단 내적항 (r(-(vxr) + wv)은 스칼라이기 때문에 -r의 내적을 각 분배할 수 있다:
					 = ( -w(v·r) + ( -r·(vxr) + r·wv ) )
				그런데 (vxr)은 당연하게도 r과 직교하는 벡터다. 따라서 직교하면 0이되는 내적의 성질상 이 항은 0이 되서 소거된다:
					= ( -w(v·r) + r·wv )
				그리고 내적은 스칼라다. 따라서 벡터 v에 곱해진 스칼라 w는 밖으로 꺼낼 수 가 있다. 따라서 실수부는 제거된다:
					= ( -w(v·r) + w(r·v) ) = 0
			   이제 남은 허수부 (rx(-(v x r) + wv)) + w(-(v x r) + wv ) + (v·r)r를 정리해보자. 외적은 벡터간의 덧셈에서 분배가 가능하다:
				   = -(rx(v x r)) + (rxwv) + w(-(v x r) + wv ) + (v·r)r
			   그리고 여기서 W도 분배해준다. 그리고 외적 성질로 인해서 결과가 같은 부분을 더한다:
					   = -(r x (v x r)) + 2w(r x v) + w²v ) + (v·r)r
			   위 식에서 w²을 어떻게해야 제거해야할까? q의 크기 qq*는 q의 실수부의 제곱 + 벡터부의 내적과 같다.
			   ∴q    = ( w, r )
			   ∵qq* = w² + r·r = 1
			   여기서 벡터부의 내적부분을 식의 결과 1로 넘기면 다음과 같이 전개가 가능하다:
			   ∴w²  = 1-r·r
			   = -(r x (v x r)) + 2w(r x v) + (1-r·r)v ) + (v·r)r
			   = -(r x (v x r)) + 2w(r x v) + v-(r·r)v + (v·r)r

				여기서부터는 삼중곱을 알아야 정리가 가능하다. 삼중곱은 세번의 외적 AxBxC를 정리한 결과는 항상 BxC로 만들어진
				평면안에 속하는 벡터가 됨을 의미한다. 삼중곱 B(A·C)-C(A·B)은 AxBxC와 결과가 동일하다. 이를 이용해서 기존 식을 치환해보자:
				 ∴rx(vxr) = r x (v x r) = v(r·r)-r(r·v)
				 위 삼중곱 식은, ∴-(r x (v x r)) + 2w(r x v) + v-(r·r)v + (v·r)r의 좌측항에 비스무리하게 보이기에, -1로 묶어서 다음과 같이
				 치환이 가능하다. 치환하면 우측항에 같은 식이 있기에, 이를 합칠 수 있다:
			   = -(r x (v x r)) + 2w(r x v) + v-(v(r·r)-r(r·v))
			   = -(r x (v x r)) + 2w(r x v) + v-(rx(vxr))
			   = -2( r x (v x r)) + 2w( r x v ) + v
			   위 식에서, -2( r x (v x r)) 부분에서 공통된 부분을 줄여서 계산량을 줄일 수 있을 것이다:
			   = -2( r x (v x r)) + 2w( r x v ) + v
			   = -2( r x -(r x v)) + 2w( r x v ) + v
			   여기서 -2는, 외적 항들에 들어갈 때 한 곳에서만 넣어줘야 한다. 외적 2vxr = 2(vxr)로 묶을 수 있지만, 2vx2r = 4(vxr)이 되어야 한다.
			   앞서 말했듯이 외적에서 한 벡터에 스칼라가 있으면 그 스칼라가 외적식 전체적으로 분배되기 때문이다. 따라서 다음과 같이 전개된다:
			   =  (r x 2(r x v)) + 2w( r x v ) + v
			   위 식에서 2( r x v )라는 식이 반복된다. 따라서 실제 계산시 미리 계산해둔 2( r x v )를 t로 두고 재사용하면 된다. 따라서 최종 정리는 다음과
			   같다:
			   ∴ t = 2( r x v )
			   =  (r x t) + wt + v
		   */






/*===========================================================================================================
 *    Quaternion의 전역 변수를 초기화한다...
 *============*/
const hyunwoo::Quaternion hyunwoo::Quaternion::Identity = { 1.f, Vector3::Zero };









/*============================================================================================================
 *    주어진 회전축 rotAxis와 직교하는 회전평면에서 angle만큼 회전시키는 사원수를 얻습니다...
 *===========*/
hyunwoo::Quaternion hyunwoo::Quaternion::AngleAxis(const float angle, const Vector3& rotAxis)
{
	/*************************************************************
	 *  왼손좌표게에서 반시계로 회전시키기위해, 각도를 뒤집어서 준다..
	 ********/
	const float rad = (Math::Angle2Rad * -angle * .5f);

	return Quaternion(
		Math::Cos(rad),
		(rotAxis * Math::Sin(rad))
	);
}









/*============================================================================================================
 *   주어진 세 각도로 오일러 회전( Yaw->Pitch->Roll )이 적용된 사원수를 얻습니다....
 *===========*/
hyunwoo::Quaternion hyunwoo::Quaternion::Euler(const float yAngle, const float xAngle, const float zAngle)
{
	return AngleAxis(zAngle, Vector3::Back) * AngleAxis(xAngle, Vector3::Right) * AngleAxis(yAngle, Vector3::Up);
}






/*=============================================================================================================
 *   인자로 주어진 from 벡터를 to 벡터로 회전시킬 수 있는 사원수를 얻습니다...
 *===============*/
hyunwoo::Quaternion hyunwoo::Quaternion::FromTo(const Vector3& from, const Vector3& to, const float angleScale)
{
	const float   c    = Vector3::Dot(from.GetNormalized(), to.GetNormalized()) * angleScale * .5f;
	const float   s    = Math::Sin(Math::Acos(Math::Clamp(c, -1.f, 1.f)));
	const Vector3 axis = Vector3::Cross(to, from);

	/*******************************************************
	 *   두 벡터가 평행하면 회전축은 0벡터다. 하지만 이는
	 *   180º 회전이다. 따라서 아무 기저 벡터 하나와 외적해도
	 *   항상 180º 회전이 가능한 회전축을 얻을 수 있다..
	 ********/
	if (axis.GetSqrMagnitude()==0.f) {
		return Quaternion(c, Vector3::Cross(from, Vector3::Up) * s);
	}

	return Quaternion(c, axis * s);
}










/*=========================================================================================================
 *    Quaternion의 켤레를 구하는 메소드들입니다......
 *=============*/
const hyunwoo::Quaternion& hyunwoo::Quaternion::Conjugate() {
	XYZ *= -1.f;
	return *this;
}

const hyunwoo::Quaternion hyunwoo::Quaternion::GetConjugate() const {
	return Quaternion(W, XYZ * -1.f);
}










/*==========================================================================================================
 *    해당 Quaternion의 크기를 얻습니다.....
 *=============*/
const float hyunwoo::Quaternion::GetMagnitude() const
{
	const Quaternion mulConjugate = operator*(GetConjugate());

	return Math::Sqrt(mulConjugate.W * mulConjugate.W + XYZ.GetSqrMagnitude());
}










/*===========================================================================================================
 *    다른 사원수를 곱합니다....
 *=============*/	
hyunwoo::Quaternion hyunwoo::Quaternion::operator *(const Quaternion& rhs) const 
{
	return Quaternion(
		(W * rhs.W) - Vector3::Dot(XYZ, rhs.XYZ),
		Vector3::Cross(XYZ, rhs.XYZ) + (rhs.XYZ * W) + (XYZ * rhs.W)
	);
}

hyunwoo::Quaternion& hyunwoo::Quaternion::operator*=(const Quaternion& rhs)
{
	operator=(operator*(rhs));
	return *this;
}










/*===============================================================================================
 *    주어진 벡터를 해당 사원수에 설정된대로 회전시킨 벡터를 얻습니다.....
 *=============*/
const hyunwoo::Vector3 hyunwoo::Quaternion::operator *(const hyunwoo::Vector3& rhs) const
{   
	/**********************************************************
	 *   기존 qvq*은 시계방향 회전이다. 따라서 q*vq로 진행해야
	 *   왼손좌표게에서의 반시계 회전이 보장된다.
	 *******/
	const Vector3 t = Vector3::Cross(XYZ, rhs) * 2.f;

	//return (*this * Quaternion(0, rhs) * GetConjugate()).XYZ;
	return Vector3::Cross(XYZ, t) + (t * W) + rhs;
}

hyunwoo::Quaternion& hyunwoo::Quaternion::operator *=(const hyunwoo::Vector3& rhs)
{
	operator=(Quaternion(0, operator*(rhs)));
	return *this;
}








/*================================================================================================
 *    해당 사원수만큼 회전이 적용된 회전 행렬을 얻습니다...
 *============*/
hyunwoo::Matrix4x4 hyunwoo::Quaternion::GetRotateMatrix() const
{
	return Matrix4x4{
		(*this * Vector3::BasisX),
		(*this * Vector3::BasisY),
		(*this * Vector3::BasisZ),
		Vector4::BasisW
	};
}








/*=================================================================================================
 *   문자열 람다에서 출력하기 위한 메소드...
 *================*/
void hyunwoo::Quaternion::AddString(std::string& sharedStr) const
{
	const float rad  = Math::Acos(W);
	const float s    = Math::Sin(rad);
	const float sDiv = (s != 0.f ? (1.f / s) : 1.f);

	sharedStr += "(angle: ";
	sharedStr += std::to_string(rad * Math::Rad2Angle * 2.f);
	sharedStr += "º, axis: ";
	(XYZ * sDiv).AddString(sharedStr);
	sharedStr += ")";
}

void hyunwoo::Quaternion::AddWString(std::wstring& sharedStr) const
{
	const float rad  = Math::Acos(W);
	const float s    = Math::Sin(rad);
	const float sDiv = (s != 0.f ? (1.f / s) : 1.f);

	sharedStr += L"(angle: ";
	sharedStr += std::to_wstring(rad * Math::Rad2Angle * 2.f);
	sharedStr += L"º, axis: ";
	(XYZ * sDiv).AddWString(sharedStr);
	sharedStr += L")";
}